/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Given an axis a in an axial algebra A, find axes b such that t_a=t_b if such exist.                                    + 
+                                                                                                                        +
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
FindTwin:=function(a)/*this must really be and axis*/
if not HasMonsterFusion(a) then return "Error, input not an axis";
	elif IsJordanAxis(a) then space:=Eigenspace(AdMat(a),1/4);
	else
		space:=Eigenspace(AdMat(a),1/32);
end if;
A:=Parent(a);
_,ann:=AnnihilatorOfSpace(A,Basis(space));
dim:=Dimension(ann);
R:=PolynomialRing(Rationals(),dim);
FR:=FieldOfFractions(R);
AFR:=ChangeField(A,FR);
_,U:=HasFrobeniusForm(A);
UFR:=ChangeRing(U,FR);
w:=&+[(AFR!ann.i)*R.i:i in [1..dim]];
aa:=AFR!Eltseq(a);
res:=w*w+2*aa*w-w;
len_res:=(VecToMat(w)*UFR*Transpose(VecToMat(w))+2*VecToMat(aa)*UFR*Transpose(VecToMat(w)))[1][1];
I:=ideal<R|[R!x:x in Eltseq(res) cat [len_res]]>;
var:=Variety(I);
if not #var eq VarietySizeOverAlgebraicClosure(I) then print "a check is needed here";
	elif #var eq 1 then 
		print "nothing new";
		return "none exist";
	elif #var gt 1 then 
			vars:=[];
			for x in var do
				if not forall{y:y in x|y eq 0} then  
					twin:=&+[AFR!ann.i*x[i]:i in [1..dim]];
					Append(~vars,a+A!Eltseq(twin));
				end if;
			end for;
			return vars;
end if;
end function;

		
