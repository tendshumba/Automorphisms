//++++++++++++++++++++++======+++++++++++++++++++++++++++++++++++++++
//The function takes a list of axes (as axial vectors) and a letter +
// as a string say "a" which the axes are going to be called by.    +
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SubAlg:=function(lst,a)
var:='a';
strings:=[Sprintf("%o_{%o}",var,i):i in [1..#lst]];
m:=1;
closed:=0;
localbas:=lst;
A:=Parent(localbas[1]);/*We want the axial algebra here, hence the
requirement above. We also assume that your list is non-empty*/
W:=VectorSpace(BaseField(A),#Eltseq(localbas[1]));
l1:=[W!Eltseq(localbas[i]): i in [1..#localbas]];
sub:=sub<W|l1>;
while closed eq 0 do
//	print #l1;

      outside:=[];outside_inds:=[];
      tups:=CartesianPower([1..#l1],2);
      tups:=[x:x in tups|x[1] le x[2]];
      prods:=[A!(l1[tups[j][1]])*(A!(l1[tups[j][2]])):j in [1..#tups]];
	//printf "There are %o products\n",#prods;
      if forall{x:x in prods| W!Eltseq(x) in sub} then
      	 closed:=1;
	  else
	  m+:=1;
	  not_in:=[x:x in prods|not W!Eltseq(x) in sub];
	  for i in [1..#not_in] do
	      if i eq 1 then
	      	 Append(~outside,not_in[1]); Append(~l1,W!Eltseq(not_in[1]));
		//print "a vector was added";
		 sub+:=sub<W|W!Eltseq(not_in[1])>;
		 //sub:=sub<W|l1>;

	      else
		w:=W!Eltseq(not_in[i]);
		if not w in sub then
		sub+:=sub<W|w>;/*may speed thigs up compared to using updated l1 below.*/

		   Append(~outside,not_in[i]);Append(~l1,w);
// print " a vector was added";
		  // sub:=sub<W|l1>;

		end if;
		 end if;
	  end for;
	  for i:=1 to #outside do
	      Append(~outside_inds,Index(prods,outside[i]));
	  end for;
	  for i:=1 to #outside_inds do
	      Append(~strings,"("*Sprintf("%o%o",strings[tups[outside_inds[i]][1]],
	      strings[tups[outside_inds[i]][2]])*")");
	  end for;
	 //CP:=CartesianProduct(l1,outside);
	 //CP:=[x:x in CP]; no need for this until the optimization.
	 //updated_out:=[]
     end if;
end while;
return sub,l1,strings,m;
end function;
